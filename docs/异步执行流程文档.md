# 异步执行流程文档

## 概述

本文档详细说明了 `AsyncSQLWrapper`、`CacheOperationHelper`、`MethodExecutor`、`ProceedingJoinPointMethodExecutor` 等类的作用、使用方法和完整执行流程。



## 核心类说明

### 1. MethodExecutor（方法执行器接口）

**作用**：通用的方法执行器接口，用于封装方法执行逻辑，替代 `ProceedingJoinPoint`，使策略类更加通用和可测试。

**核心方法**：

```java
public interface MethodExecutor {
    // 执行方法，支持传入修改后的参数
    Object execute(Object... args) throws Throwable;
    
    // 获取方法参数
    Object[] getArgs();
    
    // 获取方法签名
    Method getMethod();
    
    // 获取参数名到索引的映射（用于HASH类型缓存的字段映射）
    Map<Integer, String> getParamIndexToName();
    
    // 判断方法是否是void返回类型
    boolean isVoidMethod();
}
```

**设计优势**：
- 解耦：策略类不再依赖 AOP 框架的 `ProceedingJoinPoint`
- 可测试：接口易于 mock，便于单元测试
- 通用性：可在非 AOP 场景使用

---

### 2. ProceedingJoinPointMethodExecutor（AOP 切面实现）

**作用**：基于 `ProceedingJoinPoint` 的 `MethodExecutor` 实现，用于在 AOP 切面中包装 `ProceedingJoinPoint`。

**核心功能**：
- 包装 `ProceedingJoinPoint` 为 `MethodExecutor`
- 自动解析方法参数名（支持 MyBatis `@Param` 注解）
- 判断方法返回类型

**使用示例**：

```java
@Around("@annotation(redisCache)")
public Object handleCache(ProceedingJoinPoint joinPoint, RedisCache redisCache) {
    // 将 ProceedingJoinPoint 包装为 MethodExecutor
    MethodExecutor methodExecutor = new ProceedingJoinPointMethodExecutor(joinPoint);
    
    // 传递给策略类使用
    ReadStrategy strategy = cacheStrategyFactory.getReadStrategy(readStrategy);
    return strategy.read(cacheSyncParam, methodExecutor);
}
```

---

### 3. AsyncSQLWrapper（异步 SQL 执行包装器）

**作用**：统一管理数据库操作的同步/异步执行、重试机制和异常处理。

#### 核心方法

##### 3.1 executeAspectMethod（策略类专用）

**作用**：用于策略类调用，根据 `CacheSyncParam` 中的 `isExecuteASync` 标志决定同步或异步执行。

```java
public <T> void executeAspectMethod(CacheSyncParam<T> param, MethodExecutor methodExecutor)
```

**使用场景**：被缓存策略类（如 `CacheAsideStrategy`、`WriteThroughStrategy`）内部调用。

**执行流程**：
1. 判断方法是否为 void 类型
2. 创建 `Callable` 操作包装方法执行
3. 根据 `param.getIsExecuteASync()` 决定同步或异步
4. 异步执行时自动处理异常并发送到补偿队列

##### 3.2 executeSync（同步执行）

**作用**：同步执行数据库操作，带自动重试机制。

```java
public <T> T executeSync(Callable<T> operation)
```

**使用示例**：

```java
// Write-Through 策略：同步执行
asyncSQLWrapper.executeSync(() -> {
    followMapper.insert(userFollow);
    return null;
});
```

**特点**：
- 阻塞调用线程，直到操作完成
- 自动重试（最多 3 次，指数退避）
- 失败时抛出异常

##### 3.3 executeAsync（异步执行）

**作用**：异步执行数据库操作，返回 `CompletableFuture`。

```java
public <T> CompletableFuture<T> executeAsync(Callable<T> operation)
```

**使用示例**：

```java
// 异步执行并处理结果
CompletableFuture<Integer> future = asyncSQLWrapper.executeAsync(() -> {
    return userMapper.updateUser(user);
});

future.thenAccept(result -> {
    log.info("更新成功，影响行数: {}", result);
}).exceptionally(ex -> {
    log.error("更新失败", ex);
    return null;
});
```

**特点**：
- 非阻塞，立即返回
- 自动重试机制
- 使用线程池执行

##### 3.4 executeAsyncVoid（异步执行 void 操作）

**作用**：异步执行无返回值的数据库操作。

```java
public CompletableFuture<Void> executeAsyncVoid(Runnable operation)
```

**使用示例**：

```java
// Write-Behind 策略：异步执行
asyncSQLWrapper.executeAsyncVoid(() -> {
    postLikeMapper.insert(postLike);
}).exceptionally(ex -> {
    log.error("异步写入失败", ex);
    return null;
});
```

**典型场景**：点赞、收藏等非核心数据的持久化。

##### 3.5 executeWithRetry（带重试的执行）

**作用**：带重试机制的执行逻辑，使用 Spring Retry 注解。

```java
@Retryable(value = { SQLException.class, DataAccessException.class, RuntimeException.class }, 
           maxAttempts = 3, 
           backoff = @Backoff(delay = 1000, multiplier = 2, maxDelay = 10000))
public <T> T executeWithRetry(Callable<T> operation, String key) throws Exception
```

**重试策略**：
- 最多重试 3 次
- 初始延迟 1 秒
- 指数退避（1s → 2s → 4s）
- 最大延迟 10 秒

##### 3.6 executeBatch（批量执行）

**作用**：批量执行多个数据库操作。

```java
public <T> List<T> executeBatch(List<Callable<T>> operations)
```

**使用示例**：

```java
List<Callable<Integer>> operations = Arrays.asList(
    () -> userMapper.insert(user1),
    () -> userMapper.insert(user2),
    () -> userMapper.insert(user3)
);

List<Integer> results = asyncSQLWrapper.executeBatch(operations);
```



### 4. CacheOperationHelper（缓存操作辅助类）

**作用**：封装策略类的使用，简化 service 层的缓存操作。

#### 核心方法

##### 4.1 read（读取缓存）

```java
public <T> T read(String key, Class<T> clazz, ReadStrategyType readStrategy, MethodExecutor methodExecutor)
```

**使用示例**：

```java
// 在 service 层使用
Post post = cacheOperationHelper.read(
    "post:123", 
    Post.class, 
    ReadStrategyType.LAZY_LOAD, 
    methodExecutor
);
```



##### 4.2 write（写入缓存）

```java
public <T> void write(String key, T value, WriteStrategyType writeStrategy,
                     MethodExecutor methodExecutor, Integer expireTime, TimeUnit timeUnit)
```

**使用示例**：

```java
cacheOperationHelper.write(
    "post:123",
    post,
    WriteStrategyType.CACHE_ASIDE,
    methodExecutor,
    3600,
    TimeUnit.SECONDS
);
```



##### 4.3 delete（删除缓存）

```java
public void delete(String key, WriteStrategyType writeStrategy, MethodExecutor methodExecutor)
```



##### 4.4 从 JoinPoint 创建 MethodExecutor 的便捷方法

```java
// 从 ProceedingJoinPoint 创建并执行
public <T> T readFromJoinPoint(String key, Class<T> clazz, ReadStrategyType readStrategy,
                               ProceedingJoinPoint joinPoint)
```



## 完整执行流程

### 场景 1：AOP 切面中的缓存操作（自动）

```
用户请求
  ↓
@RedisCache 注解的方法被调用
  ↓
RedisCacheAspect.handleCache()
  ↓
创建 ProceedingJoinPointMethodExecutor (包装 joinPoint)
  ↓
根据 operation 类型选择策略
  ├─ SELECT → ReadStrategy.read()
  └─ UPDATE/DELETE → WriteStrategy.write()/delete()
       ↓
策略类内部调用 AsyncSQLWrapper.executeAspectMethod()
  ↓
根据 CacheSyncParam.isExecuteASync 决定
  ├─ true → executeAsync() (异步)
  └─ false → executeSync() (同步)
       ↓
executeWithRetry() 执行（带重试）
  ↓
返回结果
```

**代码示例**：

```java
@RedisCache(
    key = "#id",
    operation = DataOperationType.SELECT,
    readStrategy = ReadStrategyType.LAZY_LOAD
)
public Post getPost(Long id) {
    return postMapper.selectById(id);
}
```

### 场景 2：Service 层手动使用（点赞/收藏）

```
用户点赞操作
  ↓
RelationServiceImpl.likePost()
  ↓
1. 先更新 Redis（Lua 脚本原子操作）
  ↓
2. 调用 RelationPersistenceService.persistLike()
  ↓
RelationPersistenceServiceImpl.persistLike()
  ↓
使用 AsyncSQLWrapper.executeAsyncVoid()
  ↓
异步执行数据库写入（不阻塞主流程）
  ↓
返回 CompletableFuture（主流程立即返回）
```

**代码示例**：

```java
@Override
public boolean likePost(Long userId, Long postId) {
    // 1. 先更新 Redis（原子操作）
    Long added = relationScripts.executeScript(RelationScripts.LIKE_POST, keys, userId, postId);
    
    if (added != null && added > 0) {
        // 2. 异步持久化到数据库（Write-Behind 策略）
        persistenceService.persistLike(userId, postId, true)
            .exceptionally(ex -> {
                log.error("异步写入失败", ex);
                return null;
            });
        return true;
    }
    return false;
}

// persistLike 实现
public CompletableFuture<Void> persistLike(Long userId, Long postId, boolean isLike) {
    return asyncSQLWrapper.executeAsyncVoid(() -> {
        if (isLike) {
            postLikeMapper.insert(postLike);
        } else {
            postLikeMapper.delete(postId, userId);
        }
    });
}
```

### 场景 3：Write-Through 策略（关注/黑名单）

```
用户关注操作
  ↓
RelationServiceImpl.follow()
  ↓
1. 先更新 Redis
  ↓
2. 调用 RelationPersistenceService.persistFollow()
  ↓
使用 AsyncSQLWrapper.executeSync()
  ↓
同步执行数据库写入（阻塞直到完成）
  ↓
确保数据强一致性
```

**代码示例**：

```java
@Override
@Transactional
public void persistFollow(Long followerId, Long followedId, boolean isFollow) {
    // Write-Through 策略：同步执行
    asyncSQLWrapper.executeSync(() -> {
        if (isFollow) {
            followMapper.insert(userFollow);
        } else {
            followMapper.delete(followerId, followedId);
        }
        return null;
    });
}
```

---

## 异步执行数据库操作的适用场景分析

### 问题：异步执行 vs 消息队列

**您的疑问**：
> 以前写这个类觉得可以把数据库处理异步化，但当时光盯着下单物流等核心业务，觉得异步执行不靠谱，业界常用的方法是消息队列。但是对于点赞收藏或其他非核心数据还是很常用的吗？

### 答案：是的，异步执行对于非核心数据非常常用

#### 1. 核心业务 vs 非核心业务

| 业务类型 | 数据一致性要求 | 推荐方案 | 原因 |
|---------|--------------|---------|------|
| **下单、支付、物流** | 强一致性 | 消息队列（MQ） | 必须保证数据不丢失，需要持久化和可靠投递 |
| **点赞、收藏、浏览记录** | 最终一致性 | 异步执行 | 可接受短暂不一致，追求高性能 |
| **关注、黑名单** | 强一致性 | 同步执行 | 核心关系数据，需要立即生效 |

#### 2. 异步执行的适用场景

**✅ 适合使用异步执行的场景**：

1. **高频低价值操作**
   - 点赞、收藏、分享
   - 浏览记录、播放记录
   - 统计计数（阅读量、播放量）
   - 用户行为日志

2. **特点**：
   - 操作频率高（每秒数千次）
   - 数据丢失影响小（可接受）
   - 对响应时间要求高（用户体验）
   - 可以批量写入数据库

3. **优势**：
   - **性能提升**：不阻塞主流程，响应速度快
   - **数据库压力小**：可以批量写入，减少数据库连接
   - **成本低**：不需要额外的消息队列基础设施
   - **实现简单**：使用线程池即可，无需引入 MQ

#### 3. 消息队列的适用场景

**✅ 适合使用消息队列的场景**：

1. **核心业务操作**
   - 订单创建、支付
   - 库存扣减
   - 账户余额变更
   - 物流信息更新

2. **特点**：
   - 数据丢失不可接受
   - 需要持久化保证
   - 需要跨服务通信
   - 需要顺序保证或去重

3. **优势**：
   - **可靠性**：消息持久化，不丢失
   - **解耦**：服务间解耦，独立扩展
   - **削峰**：流量高峰时缓冲
   - **重试**：失败自动重试

#### 4. 业界实践

**大厂常见做法**：

1. **微博、抖音、B站**：
   - 点赞、收藏：异步执行 + Redis
   - 评论、转发：消息队列（需要通知）

2. **电商平台**：
   - 浏览记录、搜索记录：异步执行
   - 订单、支付：消息队列

3. **视频平台**：
   - 播放量、观看时长：异步执行 + 定时批量写入
   - 会员购买：消息队列

#### 5. 本项目的设计

**策略选择**：

```java
// Write-Through（同步）：关注、黑名单
asyncSQLWrapper.executeSync(() -> {
    followMapper.insert(userFollow);
});

// Write-Behind（异步）：点赞、收藏
asyncSQLWrapper.executeAsyncVoid(() -> {
    postLikeMapper.insert(postLike);
});
```

**为什么这样设计**：

1. **关注关系**：
   - 用户关注后，需要立即在数据库中可见
   - 影响推荐算法、粉丝列表等核心功能
   - 使用同步执行保证一致性

2. **点赞/收藏**：
   - 高频操作（热门帖子每秒数千点赞）
   - 数据丢失影响小（可以重新计算）
   - 使用异步执行提升性能

3. **黑名单**：
   - 安全相关，需要立即生效
   - 使用同步执行

### 总结

**异步执行数据库操作对于非核心数据（点赞、收藏等）是非常常用且推荐的做法**，原因：

1. ✅ **性能优势明显**：不阻塞主流程，用户体验好
2. ✅ **实现简单**：使用线程池即可，无需额外基础设施
3. ✅ **成本低**：不需要消息队列的运维成本
4. ✅ **适合场景**：高频低价值操作，可接受最终一致性

**但需要注意**：
- 必须有异常处理和补偿机制（本项目已实现）
- 必须有重试机制（本项目使用 Spring Retry）
- 必须有监控和告警（建议添加）

**核心业务（下单、支付）仍然推荐使用消息队列**，因为：
- 数据丢失不可接受
- 需要跨服务通信
- 需要持久化保证

---

## 最佳实践建议

### 1. 选择执行方式的决策树

```
是否需要强一致性？
├─ 是 → 同步执行（executeSync）
└─ 否 → 是否需要跨服务通信？
    ├─ 是 → 消息队列（MQ）
    └─ 否 → 异步执行（executeAsync/executeAsyncVoid）
```

### 2. 异常处理

```java
// 异步执行必须有异常处理
asyncSQLWrapper.executeAsyncVoid(() -> {
    // 数据库操作
}).exceptionally(ex -> {
    log.error("操作失败", ex);
    // 可以发送到补偿队列或记录日志
    return null;
});
```

### 3. 监控指标

建议监控：
- 异步任务执行时间
- 失败率和重试次数
- 线程池使用情况
- 数据库写入延迟

### 4. 批量优化

对于高频操作，建议批量写入：

```java
// 收集一批操作后批量执行
List<Callable<Void>> operations = new ArrayList<>();
// ... 收集操作
asyncSQLWrapper.executeBatch(operations);
```

---

## 总结

本项目的异步执行框架提供了：

1. **统一的执行接口**：`AsyncSQLWrapper` 封装了同步/异步执行逻辑
2. **自动重试机制**：使用 Spring Retry 自动重试失败的操作
3. **异常处理**：自动发送失败操作到补偿队列
4. **灵活的策略选择**：根据业务需求选择同步或异步

**对于点赞、收藏等非核心数据，异步执行是业界标准做法，既简单又高效！**

