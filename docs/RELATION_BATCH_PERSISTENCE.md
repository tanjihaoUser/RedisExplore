# 关系数据批量持久化方案

## 概述

本文档描述了点赞和收藏关系的批量持久化实现方案，采用 **定时 + 定量** 双重触发机制，参考业界最佳实践。

## 业界常见方案对比

### 1. 定时批量写入

**方案描述：**
- 每 N 秒/分钟批量写入一次（如 5 分钟）
- 适合低峰期平滑写入，减少数据库压力

**优点：**
- 实现简单，固定周期执行
- 适合低峰期场景，数据库压力可控

**缺点：**
- 高峰期可能积压大量数据
- 实时性较差，数据延迟可能达到一个周期

**适用场景：**
- 数据更新频率较低
- 对实时性要求不高
- 数据库性能有限

### 2. 定量批量写入

**方案描述：**
- 当缓冲队列达到 M 条时立即写入（如 100 条）
- 适合高峰期快速响应，避免数据积压

**优点：**
- 高峰期响应快，避免数据积压
- 批量写入效率高，减少数据库交互次数

**缺点：**
- 低峰期可能长时间不写入
- 需要监控缓冲队列大小

**适用场景：**
- 数据更新频率波动大
- 高峰期需要快速响应
- 对实时性有一定要求

### 3. 混合策略（定时 + 定量）⭐ **推荐**

**方案描述：**
- 定时触发：每 N 分钟批量写入一次
- 定量触发：当缓冲达到 M 条时立即写入
- 两者结合，兼顾性能和实时性

**优点：**
- 高峰期快速响应（定量触发）
- 低峰期平滑写入（定时触发）
- 兼顾性能和实时性

**缺点：**
- 实现相对复杂
- 需要管理定时任务和缓冲队列

**适用场景：**
- **生产环境推荐方案**
- 数据更新频率波动大
- 需要兼顾性能和实时性

### 4. 消息队列方案

**方案描述：**
- 将操作放入消息队列（如 RabbitMQ、Kafka）
- 由消费者批量消费并写入数据库

**优点：**
- 解耦业务和持久化逻辑
- 支持多消费者、负载均衡
- 支持消息持久化、重试机制

**缺点：**
- 需要引入消息队列中间件
- 系统复杂度增加
- 可能存在消息丢失风险

**适用场景：**
- 大规模分布式系统
- 需要解耦和扩展性
- 已有消息队列基础设施

## 当前实现方案

### 架构设计

```
用户操作 (点赞/收藏)
    ↓
Redis 写入 (立即)
    ↓
缓冲队列 (RelationBatchTask)
    ↓
    ├─→ 定量触发 (≥100条) → 立即批量写入
    └─→ 定时触发 (5分钟) → 定时批量写入
    ↓
数据库批量写入
```

### 核心组件

#### 1. RelationBatchTask（批量任务缓冲）

```java
public class RelationBatchTask {
    // 点赞操作缓冲：key = "postId:userId", value = true(点赞) / false(取消点赞)
    private ConcurrentMap<String, Boolean> likeOperations;
    
    // 收藏操作缓冲：key = "userId:postId", value = true(收藏) / false(取消收藏)
    private ConcurrentMap<String, Boolean> favoriteOperations;
}
```

**特点：**
- 使用 `ConcurrentHashMap` 保证线程安全
- 支持去重：同一 key 的多次操作只保留最新状态
- 例如：用户点赞后取消点赞，最终状态为未点赞，只写入一次删除操作

#### 2. 定时任务调度

```java
// 定时批量写入延迟时间：5 分钟
private static final long BATCH_FLUSH_DELAY_MS = TimeUnit.MINUTES.toMillis(5);

// 定量批量写入阈值：当缓冲达到 100 条时立即写入
private static final int BATCH_SIZE_THRESHOLD = 100;
```

**机制：**
- 使用 `ThreadPoolTaskScheduler` 管理定时任务
- 只在任务不存在时创建，避免每次操作都重置定时器
- 手动触发时取消已存在的定时任务

#### 3. 批量写入流程

```java
public void flushBatchToDatabase() {
    // 1. 获取当前缓冲的任务快照（线程安全）
    // 2. 清空原任务，准备接收新操作
    // 3. 异步执行批量写入
    // 4. 写入失败时，将任务重新放回缓冲队列（补偿机制）
}
```

**优化点：**
- **快照机制**：避免在写入过程中新操作影响当前批次
- **异步执行**：不阻塞主流程
- **补偿机制**：写入失败时重新放回缓冲队列，等待下次写入

### 配置参数

| 参数 | 默认值 | 说明 | 调优建议 |
|------|--------|------|----------|
| `BATCH_FLUSH_DELAY_MS` | 5 分钟 | 定时批量写入延迟时间 | 根据业务需求调整，高峰期可缩短至 2-3 分钟 |
| `BATCH_SIZE_THRESHOLD` | 100 条 | 定量批量写入阈值 | 根据数据库性能调整，建议 50-200 条 |

### 性能优化

#### 1. 批量 SQL 插入

```xml
<!-- PostLikeMapper.xml -->
<insert id="batchInsert">
    INSERT INTO post_like (post_id, user_id) VALUES
    <foreach collection="list" item="item" separator=",">
        (#{item.postId}, #{item.userId})
    </foreach>
</insert>
```

**优势：**
- 单次 SQL 插入多条记录，减少数据库交互次数
- 比循环插入效率提升 10-100 倍（取决于批量大小）

#### 2. 去重优化

- 同一 key 的多次操作只保留最新状态
- 例如：用户点赞 → 取消点赞 → 点赞，最终只写入一次点赞操作
- 减少无效写入，提高数据库性能

#### 3. 异步执行

- 使用 `AsyncSQLWrapper` 异步执行数据库写入
- 不阻塞主流程，提高响应速度
- 支持重试和异常处理

### 数据一致性

#### 1. 最终一致性

- Redis 立即更新，数据库延迟更新
- 适合点赞、收藏等可接受短暂不一致的场景
- 通过定时/定量批量写入保证最终一致性

#### 2. 补偿机制

- 写入失败时，将任务重新放回缓冲队列
- 等待下次定时或定量触发时重试
- 避免数据丢失

#### 3. 幂等性保证

- 批量写入前检查数据库是否已存在
- 避免重复插入，保证幂等性

## 使用示例

### 点赞操作

```java
// 用户点赞
relationPersistenceService.persistLike(userId, postId, true);
// → Redis 立即更新
// → 操作添加到缓冲队列
// → 达到 100 条或 5 分钟后批量写入数据库
```

### 收藏操作

```java
// 用户收藏
relationPersistenceService.persistFavorite(userId, postId, true);
// → Redis 立即更新
// → 操作添加到缓冲队列
// → 达到 100 条或 5 分钟后批量写入数据库
```

## 监控指标

建议监控以下指标：

1. **缓冲队列大小**：`batchTask.getTotalOperationCount()`
2. **批量写入频率**：定时写入次数、定量写入次数
3. **批量写入耗时**：每次批量写入的执行时间
4. **写入失败率**：批量写入失败的次数和比例
5. **数据延迟**：从操作到数据库写入的平均延迟

## 与 IncrementalWriteStrategy 的对比

| 特性 | RelationPersistenceService | IncrementalWriteStrategy |
|------|---------------------------|-------------------------|
| **适用场景** | 关系数据（点赞、收藏） | 实体数据（用户会话、用户详情） |
| **数据模型** | 简单的 key-value 关系 | 复杂的实体对象 |
| **缓冲方式** | 单例任务对象，所有操作共享 | 每个 key 独立的任务对象 |
| **去重策略** | 同一 key 只保留最新状态 | 增量字段累加，覆盖字段取最新值 |
| **批量写入** | 批量插入/删除 | 基于原始方法参数合并后执行 |

## 总结

当前实现采用 **定时 + 定量混合策略**，参考了业界最佳实践：

1. ✅ **定时批量写入**：每 5 分钟批量写入，适合低峰期平滑写入
2. ✅ **定量批量写入**：达到 100 条立即写入，适合高峰期快速响应
3. ✅ **去重优化**：同一 key 的多次操作只保留最新状态
4. ✅ **批量 SQL**：使用批量插入，提高数据库写入效率
5. ✅ **异步执行**：不阻塞主流程，提高响应速度
6. ✅ **补偿机制**：写入失败时重新放回缓冲队列，避免数据丢失

该方案在保证数据最终一致性的同时，显著提升了系统性能和响应速度，适合生产环境使用。

## 批量写入时的存在性检查优化

在批量写入点赞和收藏关系时，需要检查数据是否已存在，避免重复插入。当前实现已优化为**批量查询方案**，相比原来的逐条查询，性能提升 10-50 倍。

### 优化前后对比

**优化前（逐条查询）：**
```java
for (PostLike like : candidates) {
    boolean exists = postLikeMapper.exists(like.getPostId(), like.getUserId());
    if (!exists) {
        toInsert.add(like);
    }
}
// 100 条记录需要 100 次数据库交互，耗时 100-500ms
```

**优化后（批量查询）：**
```java
// 1. 批量查询已存在的记录（1 次数据库交互）
List<PostLike> existing = postLikeMapper.batchExists(candidates);

// 2. 构建 HashSet 用于快速查找
Set<String> existingSet = new HashSet<>();
for (PostLike like : existing) {
    existingSet.add(like.getPostId() + ":" + like.getUserId());
}

// 3. 过滤出需要插入的记录
List<PostLike> toInsert = candidates.stream()
    .filter(like -> !existingSet.contains(like.getPostId() + ":" + like.getUserId()))
    .collect(Collectors.toList());
// 100 条记录只需 1 次数据库交互，耗时 10-50ms
```

### 性能提升

| 指标 | 优化前 | 优化后 | 提升 |
|------|--------|--------|------|
| 数据库交互次数（100条） | 100 次 | 1 次 | **100 倍** |
| 预计耗时 | 100-500ms | 10-50ms | **10-50 倍** |
| 网络往返次数 | 100 次 | 1 次 | **100 倍** |

### 详细说明

关于批量写入时存在性检查的各种方案对比，请参考：[批量写入时存在性检查策略对比](./BATCH_EXISTENCE_CHECK_STRATEGIES.md)

该文档详细对比了：
- 逐条查询（原方案，不推荐）
- 批量查询（当前方案，推荐）✅
- 忽略检查 + 数据库唯一约束
- INSERT IGNORE / ON DUPLICATE KEY UPDATE（MySQL 特有）

并提供了性能对比、使用场景和最佳实践建议。

## 完整的数据库批量操作指南

关于数据库批量操作的完整指南，包括批量查询、批量插入、批量更新、批量删除等所有操作的详细说明，请参考：[数据库批量操作完整指南](./DATABASE_BATCH_OPERATIONS.md)

该文档包含：
- ✅ 每种批量操作的 SQL 实现和 MyBatis 实现
- ✅ 具体的使用场景和特点
- ✅ 常见问题及解决方案（唯一主键冲突、外键约束、性能问题等）
- ✅ 性能优化建议
- ✅ 事务处理和错误处理
- ✅ 数据库兼容性说明（MySQL、PostgreSQL、Oracle）

是数据库批量操作的完整参考文档。
